<!DOCTYPE book [
<!ENTITY % tnt SYSTEM "../tnt.ent">
%tnt;
]>
<chapter xmlns="http://docbook.org/ns/docbook" version="5.0"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="configuration-reference">

<title>Configuration reference</title>
<blockquote><para>
  This chapter provides a reference of options which
  can be set on the command line or in a configuration file.
</para></blockquote>

<para>
Tarantool is started by entering the command:

<programlisting><prompt>$ </prompt><userinput>tarantool</userinput></programlisting>
or
<programlisting><prompt>$ </prompt><userinput>tarantool <replaceable>Lua-initialization-file</replaceable></userinput></programlisting>
or
<programlisting><prompt>$ </prompt><userinput>tarantool <replaceable>options</replaceable></userinput></programlisting>

</para>

<section xml:id="command-line-options">
<title>Command line parameter and options</title>
  <para>

  </para>
  <itemizedlist>
    <listitem xml:id="lua-file-option">
     <para><option><replaceable>lua-initialization-file</replaceable></option></para>
     <para>Invoke the Lua program in this file,
      which by convention may have the name "script.lua",
      when starting tarantool.
      If the program invokes <code>box.cfg{}</code>,
      see the reference for a
      <olink targetptr="configuration-file">configuration file</olink>.</para>
     </listitem>
    
    <listitem xml:id="help-option">
      <para><option>--help</option>, <option>-h</option></para>
      <para>Print an annotated list of all available options and exit.</para>
    </listitem>

    <listitem xml:id="version-option">
      <para><option>--version</option>, <option>-V</option></para>
      <para>Print product name and version, for example:
        <programlisting><prompt>$ </prompt> ./tarantool --version
Tarantool 1.6.0-1084-ge067689
Target: Linux-x86_64-Debug
...
        </programlisting>
        In this example:
        <simplelist>
          <member>
            <quote>Tarantool</quote> is the name
            of the reusable asynchronous networking programming framework.
          </member>
          <member>
            The 3-number version follows the standard
            <literal>&lt;major&gt;-&lt;minor&gt;-&lt;patch&gt;</literal>
            scheme, in which <literal>&lt;major&gt;</literal> number
            is changed only rarely, <literal>&lt;minor&gt;</literal>
            is incremented for each new milestone and
            indicates possible incompatible changes,
            and <literal>&lt;patch&gt;</literal> stands for the number of
            bug fix releases made after the start of the
            milestone. The optional commit number and
            commit SHA1 are output for non-released versions
            only, and indicate how much this particular build has diverged
            from the last release.
         </member>
          <member>
            <quote>Target</quote> is the platform tarantool was built on.
            Some platform-specific details may follow this line.
         </member>
        </simplelist>
      </para>
      <note><para>
        Tarantool uses <link
        xlink:href="http://www.kernel.org/pub/software/scm/git/docs/git-describe.html">git describe</link> to produce its version id, and
        this id can be used at any time to check out the
        corresponding source from our <link
        xlink:href="git://github.com/tarantool/tarantool.git">git repository</link>.
      </para></note>
    </listitem>

  </itemizedlist>

</section>

<section xml:id="configuration-file" xreflabel="configuration file">
<title>Configuration</title>
  <para>
     Configuration parameters should be done with
     <code>box.cfg{<replaceable> key = value [, key_value ...]</replaceable>}</code>
     which should be one of the first things called, if the database
     server will be used or if ports need to be opened.
  </para>
  <para>
    Since box.cfg may contain many configuration parameters
    and since some of the parameters (such as directory addresses)
    are semi-permanent, it's best to keep box.cfg in a Lua file.
    Typically this Lua file is the initialization file
    which is specified on the tarantool command line.
    A simple example of such a file is <filename>test/box/box.lua</filename>:
<programlisting>
#!/usr/bin/env tarantool
os = require('os')

box.cfg{
    primary_port        = os.getenv("PRIMARY_PORT"),
    admin_port          = os.getenv("ADMIN_PORT"),
    slab_alloc_arena    = 0.1,
    pid_file            = "tarantool.pid",
    rows_per_wal        = 50
}
</programlisting>
  </para>
  <para>
    Most configuration parameters are for allocating resources,
    opening ports, and specifying database behavior.
    All parameters are optional.
    A few parameters are dynamic, that is, they can be changed
    at runtime by calling box.cfg{} a second time.
  </para>
  <para>
    To see all the non-null parameters, say <code>box.cfg</code> (no parentheses).
    To see a particular parameter, for example the primary port, say <code>box.cfg.primary_port</code>.
  </para>
  <para>
    The following tables describe all parameters for basic operation,
    for storage, for binary logging and snapshots, for replication,
    for networking, for logging, and for hot standby.
  </para>

  <table frame='all' pgwide='1'>
    <title>Basic parameters</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry>username</entry>
          <entry>string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>UNIX user name to switch to after start.</entry>
        </row>

        <row>
          <entry xml:id="work_dir" xreflabel="work_dir">work_dir</entry>
          <entry>string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>A directory where database working files will be stored.
          The server switches to work_dir with chdir(2) after
          start. Can be relative to the current directory.
          If not specified, defaults to the current directory.</entry>
        </row>

        <row>
          <entry xml:id="wal_dir" xreflabel="wal_dir">wal_dir</entry>
          <entry>string</entry>
          <entry>"."</entry>
          <entry>no</entry>
          <entry>A directory where write-ahead log (.xlog) files are stored.
          Can be relative to work_dir. Most commonly used so
          that snapshot files and write-ahead log files
          can be stored on separate disks.
          If not specified, defaults to work_dir.</entry>
        </row>

        <row>
          <entry xml:id="snap_dir" xreflabel="snap_dir">snap_dir</entry>
          <entry>string</entry>
          <entry>"."</entry>
          <entry>no</entry>
          <entry>A directory where snapshot (.snap) files will be stored. Can be
          relative to work_dir. If not specified, defaults to
          work_dir. See also <olink targetptr="wal_dir"/>.</entry>
        </row>
        <row>
          <entry xml:id="core-dump" xreflabel="core-dump">coredump</entry>
          <entry>0 or 1</entry>
          <entry>0</entry>
          <entry>no</entry>          
          <entry>Deprecated. Do not use.</entry>
        </row>
        <row>
          <entry xml:id="primary_port" xreflabel="primary_port">primary_port</entry>
          <entry>integer or string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>The read/write data port number or URI (Universal Resource Identifier) string.
          Has no default value, so <emphasis
          role="strong">must be specified</emphasis>
          if connections will occur from remote clients
          that do not use admin_port.
          Note: a replica also binds to this port, and accepts
          connections, but these connections can only serve
          reads until the replica becomes a master.
          A typical value is 3303.</entry>
        </row>

        <row>
          <entry xml:id="admin_port" xreflabel="admin_port">admin_port</entry>
          <entry>integer or string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>The port or URI to listen on for administrative
          connections. Has no default value, so must be specified
          if connections will occur via telnet. Not used unless
          assigned a value. This may be expressed with URI = Universal
          Resource Identifier format, for example "unix://unix_domain_socket",
          or as a numeric TCP port. Connections are often made with telnet.
          A typical value is 3313.</entry>
        </row>

        <row>
          <entry>pid_file</entry>
          <entry>string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>Store the process id in this file. Can be
          relative to work_dir. A typical value is "tarantool.pid".</entry>
        </row>

        <row>
          <entry xml:id="custom_proc_title"
                 xreflabel="custom_proc_title">
            custom_proc_title
          </entry>
          <entry>string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>
            <para>Inject the given string into <olink
            targetptr="proctitle">server process title</olink>
            (what's shown in the COMMAND column for <command>ps</command>
            and <command>top</command> commands). For example,
             ordinarily <command>ps</command> shows the Tarantool server process thus:
            </para>
<programlisting>kostja@shmita:~$ ps -a -o command | grep box
tarantool: primary pri: 3303 adm: 33135</programlisting>
          <para>But if the configuration file contains custom_proc_title=sessions then
          the output looks like:</para>
<programlisting>kostja@shmita:~$ ps -a -o command | grep box
tarantool: primary@sessions pri: 3303 adm: 3313</programlisting>
          </entry>
        </row>

        <row>
          <entry>background</entry>
          <entry>boolean</entry>
          <entry>false</entry>
          <entry>no</entry>
          <entry>Run the server as a background task.
          The logger and pid_file parameters must be non-null for this to work.</entry>
        </row>

      </tbody>
    </tgroup>
  </table>

  <table frame='all' pgwide='1'>
    <title>Configuring the storage</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry>slab_alloc_arena</entry>
          <entry>float</entry>
          <entry>1.0</entry>
          <entry>no</entry>
          <entry>
            <anchor xml:id="slab_alloc_arena" xreflabel="slab_alloc_arena"/>
            How much memory Tarantool
          allocates to actually
          store tuples, <emphasis role="strong">in
          gigabytes</emphasis>. When the limit is reached, INSERT
          or UPDATE requests begin failing with error
          <olink targetptr="ER_MEMORY_ISSUE"/>.
          While the server does not go
          beyond the defined limit to allocate tuples, there is
          additional memory used to store indexes and connection
          information.  Depending on actual configuration and
          workload, Tarantool can consume up to 20% more than the
          limit set here.</entry>
        </row>

        <row>
          <entry>slab_alloc_minimal</entry>
          <entry>integer</entry>
          <entry>64</entry>
          <entry>no</entry>
          <entry>Size of the smallest allocation unit. It can be
          tuned down if most of the tuples are very small.</entry>
        </row>

        <row>
          <entry>slab_alloc_factor</entry>
          <entry>float</entry>
          <entry>2.0</entry>
          <entry>no</entry>
          <entry>Use slab_alloc_factor as the multiplier for
          computing the sizes of memory chunks that tuples are
          stored in. A lower value  may result in less wasted
          memory depending on the total amount of memory available
          and the distribution of item sizes.</entry>
        </row>

      </tbody>
    </tgroup>
  </table>

  <table frame='all' pgwide='1'>
    <title>Binary logging and snapshots</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry>panic_on_snap_error</entry>
          <entry>boolean</entry>
          <entry>true</entry>
          <entry>no</entry>
          <entry>If there is an error reading the snapshot file (at
            server start), abort.</entry>
        </row>

        <row>
          <entry>panic_on_wal_error</entry>
          <entry>boolean</entry>
          <entry>false</entry>
          <entry>no</entry>
          <entry>If there is an error reading a write-ahead
          log file (at server start), abort.</entry>
        </row>

        <row>
          <entry xml:id="rows_per_wal" xreflabel="rows_per_wal">rows_per_wal</entry>
          <entry>integer</entry>
          <entry>500000</entry>
          <entry>no</entry>
          <entry>How many log records to store in a single
          write-ahead log file. When this limit is reached, Tarantool
          creates another WAL file named
          <filename>&lt;first-lsn-in-wal&gt;.xlog</filename>
          This can be useful for simple rsync-based backups.
          </entry>
        </row>

        <row>
          <entry>snap_io_rate_limit</entry>
          <entry>float</entry>
          <entry>null</entry>
          <entry><emphasis role="strong">yes</emphasis></entry>
          <entry>Reduce the throttling effect of <olink
          targetptr="box.snapshot"/> on INSERT/UPDATE/DELETE
          performance by setting a limit on
          how many megabytes per second it can write to disk.
          The same can be achieved by splitting <olink
          targetptr="wal_dir"/> and <olink targetptr="snap_dir"/>
          locations and moving snapshots to a separate disk.</entry>
        </row>

        <row>
          <entry xml:id="wal_mode" xreflabel="wal_mode">wal_mode</entry>
          <entry>string</entry>
          <entry>"write"</entry>
          <entry><emphasis role="strong">yes</emphasis></entry>
          <entry>Specify fiber-WAL-disk synchronization mode as:
              <emphasis>none:</emphasis> write-ahead log is not maintained; <emphasis>write:</emphasis> fibers wait for their data to
              be written to the write-ahead log (no fsync(2)); <emphasis>fsync</emphasis>:
              fibers wait for their data, fsync(2) follows each write(2);
          </entry>
        </row>

        <row>
          <entry xml:id="wal_dir_rescan_delay" xreflabel="wal_dir_rescan_delay">wal_dir_rescan_delay</entry>
          <entry>float</entry>
          <entry>0.1</entry>
          <entry>no</entry>
          <entry>Number of seconds between periodic scans of the
          write-ahead-log file directory, when checking for
          changes to write-ahead-log files for the sake of
          replication or local hot standby.</entry>
        </row>

      </tbody>
    </tgroup>
  </table>

  <table frame='all' pgwide='1'>
    <title>Replication</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry xml:id="replication_source"
          xreflabel="replication_source">replication_source</entry>
          <entry>string</entry>
          <entry>null</entry>
          <entry><emphasis role="strong">yes</emphasis></entry>
          <entry>If replication_source is not an empty string, the
          server is considered to be a Tarantool replica.
          The replica server will try to connect to the master
          which replication_source specifies with format ip:port.
          For example, if replication_source = "1.2.3.4:55555" then
          the replica server tries to connect to 1.2.3.4 port 55555.
          A replica server does not accept updates
          on <olink targetptr="primary_port"/>. This parameter is
          dynamic, that is, to enter master mode, simply set
          replication_source to an empty string and issue
          "box.cfg{replication_source=new-value}".</entry>
        </row>

      </tbody>
    </tgroup>
  </table>

  <table frame='all' pgwide='1'>
    <title>Networking</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry>io_collect_interval</entry>
          <entry>float</entry>
          <entry>null</entry>
          <entry><emphasis role="strong">yes</emphasis></entry>
          <entry>The server will sleep for io_collect_interval seconds
          between iterations of the event loop. Can be
          used to reduce CPU load in deployments in which the
          number of client connections is large, but requests are
          not so frequent (for example, each connection issues
          just a handful of requests per second). </entry>
        </row>

        <row>
          <entry>readahead</entry>
          <entry>integer</entry>
          <entry>16320</entry>
          <entry>no</entry>
          <entry>The size of the read-ahead buffer associated with a
          client connection. The larger the buffer, the more
          memory an active connection consumes and the more requests
          can be read from the operating system buffer in a single
          system call. The rule of thumb is to make sure the buffer
          can contain at least a few dozen requests. Therefore, if
          a typical tuple in a request is large, e.g. a few
          kilobytes or even megabytes, the read-ahead buffer size should
          be increased.  If batched request processing is not
          used, it's prudent to leave this setting at its
          default.</entry>
        </row>

      </tbody>
    </tgroup>
  </table>

  <table frame='all' pgwide='1'>
    <title>Logging</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry>log_level</entry>
          <entry>integer</entry>
          <entry>5</entry>
          <entry><emphasis role="strong">yes</emphasis></entry>
          <entry>How verbose the logging is. There are 5 log
            verbosity classes: 1 -- ERROR, 2 -- CRITICAL, 3 --
            WARNING, 4 -- INFO, 5 -- DEBUG. By setting log_level,
            one can enable logging of all classes below or equal
            to the given level. Tarantool prints its logs to the
            standard error stream by default, but this can be
            changed with the "logger" configuration parameter.
          </entry>
        </row>

        <row>
          <entry>logger</entry>
          <entry>string</entry>
          <entry>null</entry>
          <entry>no</entry>
          <entry>By default, the log is sent to the standard
          error stream (<filename>stderr</filename>). If logger
          is given a value, Tarantool creates a child process,
          executes the command indicated by the value, and pipes its standard
          output to the standard input of the created process.
          Example setting: <command>tee -a
          tarantool.log</command> (this will duplicate log output
          to <filename>stdout</filename> and a log file).
          </entry>
        </row>

        <row>
          <entry>logger_nonblock</entry>
          <entry>boolean</entry>
          <entry>true</entry>
          <entry>no</entry>
          <entry>If logger_nonblock equals true, Tarantool does not
          block on the log file descriptor when it's not
          ready for write, and drops the message instead. If
          log_level is high, and a lot of messages go to the log
          file, setting logger_nonblock to true may improve logging
          performance at the cost of some log messages getting
          lost.</entry>
        </row>

        <row>
          <entry>too_long_threshold</entry>
          <entry>float</entry>
          <entry>0.5</entry>
          <entry><emphasis role="strong">yes</emphasis></entry>
          <entry>If processing a request takes longer than the
          given value (in seconds), warn about it in the log.
          Has effect only if log_level is less than or equal to 3
          (WARNING).</entry>
        </row>

      </tbody>
    </tgroup>
  </table>

  <table frame='all' pgwide='1'>
    <title>Hot Standby</title>
    <tgroup cols='5' colsep='1' rowsep='1'>
      <colspec colnum="1" colname="col1" colwidth="2*"/>
      <colspec colnum="5" colname="col4" colwidth="6*"/>

      <thead>
        <row>
          <entry>Name</entry>
          <entry>Type</entry>
          <entry>Default</entry>
          <entry>Dynamic?</entry>
          <entry>Description</entry>
        </row>
      </thead>

      <tbody>

        <row>
          <entry>local_hot_standby</entry>
          <entry>boolean</entry>
          <entry>true</entry>
          <entry>no</entry>
          <entry>
            <anchor xml:id="local_hot_standby" xreflabel="local_hot_standby"/>
          In version 1.6 local hot standby is always on so this is a legacy setting.
          When local_hot_standby=true, the expectation is that there will be two
          instances of the server using the same configuration file.
          The first one to start will be the "primary" instance.
          The second one to start will be the "standby" instance.
          The standby instance will initialize and will try to connect on primary_port
          and admin_port, but will fail because the
          primary instance has already taken them.
          So the standby instance goes into a loop, reading the write
          ahead log which the primary instance is writing (so the
          two instances are always in synch), and trying to connect on the
          ports. If the primary instance goes down for any reason,
          the ports will become free so the standby instance will
          succeed in connecting, and will become the primary instance.
          Thus there is no noticeable downtime if the primary instance goes down.
          When local_hot_standby=true, replication_source should be an
          empty string and wal_mode should not be equal to "none".
          </entry>
        </row>
      </tbody>
    </tgroup>
  </table>
  
</section>
</chapter>

<!--
vim: tw=66 syntax=docbk
vim: spell spelllang=en_us
-->
